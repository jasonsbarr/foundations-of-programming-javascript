{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! If you're ready to learn how to program in JavaScript, and I mean really program in JavaScript, you've come to the right place. My goal here is not just to teach you the JavaScript language, but to help you become a solid programmer and build the foundation for a lifelong journey into the world of software engineering. Knowing the language isn't enough Anyone can learn the basics of a programming language and think of themselves as a \"programmer,\" but in reality it takes a lot more than just knowing a language. You must also learn how to design programs well, how to write maintainable, modular code, and how to use the most efficient and effective algorithms and data structures to get the job done. This course is designed to give you exactly those skills. What makes this course different Most \"learn to program\" courses don't have what it takes to give you a real foundation for success. They'll teach you the basics of a language, sure, and you'll do some coding along and build some projects that may even look really nice, but when it comes to designing and building things on your own... forget it. I'm going to take you from writing your very first line of code to building complex programs that do more than you ever thought yourself capable of. You won't just learn how to write code; you'll learn how to think like an engineer and apply the very same skills and techniques people pay thousands of dollars for at a bootcamp or in a college degree program... And it won't cost you a dime. How the course is structured This course is designed to help you learn, and I mean really learn. There are numerous quizzes, Feynman exercises (where you explain what you're learning in your own words), and programming exercises from beginning to end. There are also some code-alongs and guided projects where I demonstrate how to design and build more complex programs. Then there are actual, do-it-yourself-for-real projects where I'll give you the project specification, maybe some starter files, and then it's up to you to build it. Quizzes and exercises are all cumulative and everything builds on earlier material, which gives me a chance to use spaced repetition throughout the course. That means I can repeat concepts and important information to maximize your opportunity to make sure the concepts get firmly embedded in your memory. Finally, a comprehensive assessment gauges your progress over the entire course and a massive final project lets you demonstrate everything you've learned. You could even use it as a portfolio piece once you're finished! It won't be easy I'm not gonna lie; this is going to be a lot of work. Learning how to program the right way is a damned difficult thing to do. There will be times when you'll be so frustrated you just want to quit. I'm going to tell you right now that, while those moments are incredibly frustrating, they're also necessary\u2014and they're the moments that will lead you to your biggest, most satisfying breakthroughs! The path to mastery can only be reached by riding the struggle bus. And when you have your breakthrough... well, it's a hell of a feeling. You'll see what I mean. Course requirements You need to use a modern browser, preferably on a desktop or laptop computer, to do the code exercises and projects. This means a recent (preferably the latest) version of Chrome, Firefox, Edge, or Safari. It's not impossible to use a tablet, but you'll be much better off with a full-size keyboard. Trust me. If you want to use your own code editor for projects and exercises, I'll provide links to the repository files so you can download them. It's not necessary, though, because everything you need will be embedded in the pages here. That includes code editors, exercises, project starter files... everything ! Most importantly, you need to have a desire to learn, a willingness to be taught, and the drive to keep pushing when you hit the wall and things get hard. Take a break, take a walk around the block, take a cigarette break (don't do that, smoking is bad for you), or whatever you need to let your mind get unstuck, then come back and look at the problem again with fresh eyes and a ready mind. Are you ready? Let's dive in!","title":"Home"},{"location":"#welcome","text":"If you're ready to learn how to program in JavaScript, and I mean really program in JavaScript, you've come to the right place. My goal here is not just to teach you the JavaScript language, but to help you become a solid programmer and build the foundation for a lifelong journey into the world of software engineering.","title":"Welcome!"},{"location":"#knowing-the-language-isnt-enough","text":"Anyone can learn the basics of a programming language and think of themselves as a \"programmer,\" but in reality it takes a lot more than just knowing a language. You must also learn how to design programs well, how to write maintainable, modular code, and how to use the most efficient and effective algorithms and data structures to get the job done. This course is designed to give you exactly those skills.","title":"Knowing the language isn't enough"},{"location":"#what-makes-this-course-different","text":"Most \"learn to program\" courses don't have what it takes to give you a real foundation for success. They'll teach you the basics of a language, sure, and you'll do some coding along and build some projects that may even look really nice, but when it comes to designing and building things on your own... forget it. I'm going to take you from writing your very first line of code to building complex programs that do more than you ever thought yourself capable of. You won't just learn how to write code; you'll learn how to think like an engineer and apply the very same skills and techniques people pay thousands of dollars for at a bootcamp or in a college degree program... And it won't cost you a dime.","title":"What makes this course different"},{"location":"#how-the-course-is-structured","text":"This course is designed to help you learn, and I mean really learn. There are numerous quizzes, Feynman exercises (where you explain what you're learning in your own words), and programming exercises from beginning to end. There are also some code-alongs and guided projects where I demonstrate how to design and build more complex programs. Then there are actual, do-it-yourself-for-real projects where I'll give you the project specification, maybe some starter files, and then it's up to you to build it. Quizzes and exercises are all cumulative and everything builds on earlier material, which gives me a chance to use spaced repetition throughout the course. That means I can repeat concepts and important information to maximize your opportunity to make sure the concepts get firmly embedded in your memory. Finally, a comprehensive assessment gauges your progress over the entire course and a massive final project lets you demonstrate everything you've learned. You could even use it as a portfolio piece once you're finished!","title":"How the course is structured"},{"location":"#it-wont-be-easy","text":"I'm not gonna lie; this is going to be a lot of work. Learning how to program the right way is a damned difficult thing to do. There will be times when you'll be so frustrated you just want to quit. I'm going to tell you right now that, while those moments are incredibly frustrating, they're also necessary\u2014and they're the moments that will lead you to your biggest, most satisfying breakthroughs! The path to mastery can only be reached by riding the struggle bus. And when you have your breakthrough... well, it's a hell of a feeling. You'll see what I mean.","title":"It won't be easy"},{"location":"#course-requirements","text":"You need to use a modern browser, preferably on a desktop or laptop computer, to do the code exercises and projects. This means a recent (preferably the latest) version of Chrome, Firefox, Edge, or Safari. It's not impossible to use a tablet, but you'll be much better off with a full-size keyboard. Trust me. If you want to use your own code editor for projects and exercises, I'll provide links to the repository files so you can download them. It's not necessary, though, because everything you need will be embedded in the pages here. That includes code editors, exercises, project starter files... everything ! Most importantly, you need to have a desire to learn, a willingness to be taught, and the drive to keep pushing when you hit the wall and things get hard. Take a break, take a walk around the block, take a cigarette break (don't do that, smoking is bad for you), or whatever you need to let your mind get unstuck, then come back and look at the problem again with fresh eyes and a ready mind.","title":"Course requirements"},{"location":"#are-you-ready","text":"Let's dive in!","title":"Are you ready?"},{"location":"intro/computers/","text":"Computers and programming This is a course about learning to program computers. \"Well, duh,\" you might say, but have you thought about what that really means? And what exactly is a computer? When you can answer the second question, that goes a long way towards answering the first: what is a computer? The first computers Today we think of computers as electronic machines that do all sorts of things for us, but the first \"computers\" were actually human beings. In fact, the earliest reference to the word \"computer\" comes from a book published in 1613. It was talking about a person who did mathematical calculations. \"Computer\" as a term was used exclusively in this manner until mechanical computing machines became more commonplace around the late 19th century. Early electronic computers UNIVAC I, one of the first commercially available electronic computers The first electronic computers were build about the time of World War II, and they were huge \u2014big enough to fill a room... or even several rooms. They were also enormously expensive. The UNIVAC I, an early commercial computer first sold to the US Census Bureau and the US Air Force, sold at a price between $1,250,000 and $1,500,000, which was over $12 million in 2020 dollars! Advances in engineering helped us build smaller and smaller computers that were ever more powerful, to such an extent that you can now carry a fully-functional computer in your pocket that has massively more computing power than the room-sized behemoths of the past. Computers, computing, and computer science A computer's job, whether human or electronic, is to do the work of computing . To oversimplify in the extreme, computing is the act of calculating the solution to a problem. This is true whether the problem is mathematical/numeric, scientific, literary, artistic, or from some other domain. This necessarily brings us to the topic of computer science. You don't need to educate yourself on the fine details of computer science to be a programmer, but it helps to at least have a solid grounding in the fundamentals. If computers do the work of computing, and if computing is the act of calculating solutions, then computer science is the study of how computing works. We might broadly say it seeks to answer these 3 questions: What can we compute? How can we best compute it? What can we do with the result? For those of us who are just starting in our journey with computers and programming, the answers to questions 2 and 3 are most pertinent. They give us an excellent starting point for thinking about programming a computer. Programming and programs The act of programming a computer is fundamentally about telling a computer what to do in order to calculate some result, and what to do with it. It's as simple as that! At its most basic level, a program is simply a piece of written language that tells the computer to perform a certain computation. How exactly a program is written depends on many things: the programming language, the programmer's style, and in some cases even the machine the program is written for. For example, a program can have detailed instructions on how the computer should compute a solution. This is known as imperative programming style. A program could also simple tell the computer what to do , and let it handle the steps itself. This is declarative programming style. Some languages require you to use one style or the other, but JavaScript is flexible enough to let you mix the two styles as appropriate for your programs. In this course you'll become fluent in both styles and learn a bit about how to determine what style is best for the task you're trying to accomplish. Programming languages Programming languages have come a long way since the earliest computers. They had to be programmed in binary, meaning you had to actually tell the computer the exact values to read and write to perform a computation. That's because computers don't read human languages; they only communicate in binary, which is a number system made up only of 1s and 0s. This was extremely inefficient and error-prone, so computer scientists invented programming languages that could be compiled and interpreted. Compiled programs are run through a translator program that turns a human-readable program into machine language so it can be executed. Interpreted programs are run through a translator program that executes the program's instructions on the fly, without the intermediate step of compiling. They are usually slower than compiled programs because the computer has to translate the code into a format it can read line-by-line instead of having it done in advance. JavaScript is technically an interpreted language, though modern JavaScript engines blur the lines between compiling and interpreting the code with a specialized technique known as Just-In-Time compiling. This allows your browser and other JavaScript runtime environments to work more efficiently without making you compile the code to binary in advance. A runtime environment is a kind of container program that allows a language to run inside it. The runtime handles the interaction between the programming language and the computer itself. Aside: Symbolic programming Symbolic programming is the use of symbols , such as words, images, musical notation, etc. in computing. Symbolic programming allows us to think of computers as more than just mathematical or engineering devices, and to apply computing to the whole range of human life to solve any number of problems in vastly different domains. Ada Lovelace was a 19th century writer and mathematician who worked with the inventor Charles Babbage to popularize his work, which included designs for early mechanical computers. His design for the Analytical Engine has been proven to be capable of performing any computation a modern computer can execute. Babbage only regarded the device for its potential mathematical and scientific capabilities; however, Lovelace wrote: [The Analytical Engine] might act upon other things besides number, were objects found whose mutual fundamental relations could be expressed by those of the abstract science of operations, and which should be also susceptible of adaptations to the action of the operating notation and mechanism of the engine...Supposing, for instance, that the fundamental relations of pitched sounds in the science of harmony and of musical composition were susceptible of such expression and adaptations, the engine might compose elaborate and scientific pieces of music of any degree of complexity or extent. Thus Lovelace anticipated the implications of modern computing, which is used in just about every area in which humans work and play, to a far greater degree than even the designer of the first complete computer could even imagine. Let's start learning how to make her vision a reality!","title":"Computers and computing"},{"location":"intro/computers/#computers-and-programming","text":"This is a course about learning to program computers. \"Well, duh,\" you might say, but have you thought about what that really means? And what exactly is a computer? When you can answer the second question, that goes a long way towards answering the first: what is a computer?","title":"Computers and programming"},{"location":"intro/computers/#the-first-computers","text":"Today we think of computers as electronic machines that do all sorts of things for us, but the first \"computers\" were actually human beings. In fact, the earliest reference to the word \"computer\" comes from a book published in 1613. It was talking about a person who did mathematical calculations. \"Computer\" as a term was used exclusively in this manner until mechanical computing machines became more commonplace around the late 19th century.","title":"The first computers"},{"location":"intro/computers/#early-electronic-computers","text":"UNIVAC I, one of the first commercially available electronic computers The first electronic computers were build about the time of World War II, and they were huge \u2014big enough to fill a room... or even several rooms. They were also enormously expensive. The UNIVAC I, an early commercial computer first sold to the US Census Bureau and the US Air Force, sold at a price between $1,250,000 and $1,500,000, which was over $12 million in 2020 dollars! Advances in engineering helped us build smaller and smaller computers that were ever more powerful, to such an extent that you can now carry a fully-functional computer in your pocket that has massively more computing power than the room-sized behemoths of the past.","title":"Early electronic computers"},{"location":"intro/computers/#computers-computing-and-computer-science","text":"A computer's job, whether human or electronic, is to do the work of computing . To oversimplify in the extreme, computing is the act of calculating the solution to a problem. This is true whether the problem is mathematical/numeric, scientific, literary, artistic, or from some other domain. This necessarily brings us to the topic of computer science. You don't need to educate yourself on the fine details of computer science to be a programmer, but it helps to at least have a solid grounding in the fundamentals. If computers do the work of computing, and if computing is the act of calculating solutions, then computer science is the study of how computing works. We might broadly say it seeks to answer these 3 questions: What can we compute? How can we best compute it? What can we do with the result? For those of us who are just starting in our journey with computers and programming, the answers to questions 2 and 3 are most pertinent. They give us an excellent starting point for thinking about programming a computer.","title":"Computers, computing, and computer science"},{"location":"intro/computers/#programming-and-programs","text":"The act of programming a computer is fundamentally about telling a computer what to do in order to calculate some result, and what to do with it. It's as simple as that! At its most basic level, a program is simply a piece of written language that tells the computer to perform a certain computation. How exactly a program is written depends on many things: the programming language, the programmer's style, and in some cases even the machine the program is written for. For example, a program can have detailed instructions on how the computer should compute a solution. This is known as imperative programming style. A program could also simple tell the computer what to do , and let it handle the steps itself. This is declarative programming style. Some languages require you to use one style or the other, but JavaScript is flexible enough to let you mix the two styles as appropriate for your programs. In this course you'll become fluent in both styles and learn a bit about how to determine what style is best for the task you're trying to accomplish.","title":"Programming and programs"},{"location":"intro/computers/#programming-languages","text":"Programming languages have come a long way since the earliest computers. They had to be programmed in binary, meaning you had to actually tell the computer the exact values to read and write to perform a computation. That's because computers don't read human languages; they only communicate in binary, which is a number system made up only of 1s and 0s. This was extremely inefficient and error-prone, so computer scientists invented programming languages that could be compiled and interpreted. Compiled programs are run through a translator program that turns a human-readable program into machine language so it can be executed. Interpreted programs are run through a translator program that executes the program's instructions on the fly, without the intermediate step of compiling. They are usually slower than compiled programs because the computer has to translate the code into a format it can read line-by-line instead of having it done in advance. JavaScript is technically an interpreted language, though modern JavaScript engines blur the lines between compiling and interpreting the code with a specialized technique known as Just-In-Time compiling. This allows your browser and other JavaScript runtime environments to work more efficiently without making you compile the code to binary in advance. A runtime environment is a kind of container program that allows a language to run inside it. The runtime handles the interaction between the programming language and the computer itself.","title":"Programming languages"},{"location":"intro/computers/#aside-symbolic-programming","text":"Symbolic programming is the use of symbols , such as words, images, musical notation, etc. in computing. Symbolic programming allows us to think of computers as more than just mathematical or engineering devices, and to apply computing to the whole range of human life to solve any number of problems in vastly different domains. Ada Lovelace was a 19th century writer and mathematician who worked with the inventor Charles Babbage to popularize his work, which included designs for early mechanical computers. His design for the Analytical Engine has been proven to be capable of performing any computation a modern computer can execute. Babbage only regarded the device for its potential mathematical and scientific capabilities; however, Lovelace wrote: [The Analytical Engine] might act upon other things besides number, were objects found whose mutual fundamental relations could be expressed by those of the abstract science of operations, and which should be also susceptible of adaptations to the action of the operating notation and mechanism of the engine...Supposing, for instance, that the fundamental relations of pitched sounds in the science of harmony and of musical composition were susceptible of such expression and adaptations, the engine might compose elaborate and scientific pieces of music of any degree of complexity or extent. Thus Lovelace anticipated the implications of modern computing, which is used in just about every area in which humans work and play, to a far greater degree than even the designer of the first complete computer could even imagine. Let's start learning how to make her vision a reality!","title":"Aside: Symbolic programming"}]}